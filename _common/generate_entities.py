import argparse
from pathlib import Path
import re
import shutil

def parse_sql_file(file_path):
    # Regular expression to match CREATE TABLE and its fields
    table_pattern = re.compile(r'CREATE TABLE (\w+)\s*\((.*?)\);', re.S)
    field_pattern = re.compile(r'^\s*(\w+)\b.*?(?:,|$)', re.M)

    content = file_path.read_text()

    tables = {}
    for table, fields in table_pattern.findall(content):
        # Filter out lines that start with FOREIGN KEY
        field_lines = [line for line in fields.splitlines() if not line.strip().startswith('FOREIGN KEY')]
        field_names = [field_pattern.match(line).group(1) for line in field_lines if field_pattern.match(line)]
        tables[table] = field_names
    return tables


def clean_directory(directory):
    if directory.exists():
        shutil.rmtree(directory)
    directory.mkdir(parents=True, exist_ok=True)

def generate_hpp_files(tables, output_dir):
    # Updated template to include the table name as a static constexpr member
    template = '''#pragma once

#include <string>

struct {struct_name}
{{
    static constexpr const char* TABLE_NAME = "{table_name}";
{fields}
}};
'''
    filenames = []
    
    for table, fields in tables.items():
        field_str = '    std::string\n        ' + ',\n        '.join(fields) + ';'
        struct_name = table.capitalize()
        # Use the Path object to handle file paths
        hpp_filename = Path(output_dir) / f"{table}.hpp"
        # Format template using both struct_name and table (converted to the required format)
        hpp_content = template.format(struct_name=struct_name, fields=field_str, table_name=table)
        hpp_filename.write_text(hpp_content, encoding='utf-8')  # Ensure encoding is specified
        filenames.append(hpp_filename.name)
    
    return filenames

def main():
    parser = argparse.ArgumentParser(description='Generate C++ header files from SQL definitions.',
                                     epilog='Example: python3 generate_entities.py ../scripts/create_db.sql AutoGenerated/include/common/Entities')
    parser.add_argument('sqlfile', type=Path, help='The SQL file to process. This file should contain CREATE TABLE statements.')
    parser.add_argument('outputdir', type=Path, help='The directory to output the HPP files. The directory will be cleaned if it exists.')

    args = parser.parse_args()
    
    clean_directory(args.outputdir)
    tables = parse_sql_file(args.sqlfile)
    generated_files = generate_hpp_files(tables, args.outputdir)

    print("Generated files:")
    for filename in generated_files:
        print("+ " + filename)

if __name__ == "__main__":
    main()
